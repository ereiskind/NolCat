"""This module contains the fixtures and configurations for testing.

The fixtures for connecting to the database are primarily based upon the fixtures at https://github.com/alysivji/flask-family-tree-api/blob/master/tests/conftest.py with some further modifications based on the code at https://spotofdata.com/flask-testing/. The test data is a small subset of the institution's own data, with usage numbers changes for confidentiality, with items selected to contain as many edge cases as possible. All test data is stored in dataframes in other files to remove encoding issues that might arise when reading data in from a tabular file but still allow the data to be exported to a tabular file.
"""

import pytest
import logging
from pathlib import Path
import os
import io
import datetime
import calendar
from sqlalchemy import create_engine
from requests_toolbelt.multipart.encoder import MultipartEncoder
from dateutil.relativedelta import relativedelta  # dateutil is a pandas dependency, so it doesn't need to be in requirements.txt

from nolcat.app import db as _db  # `nolcat.app` imports don't use wildcard because of need for alias here
from nolcat.app import create_app
from nolcat.app import configure_logging
from nolcat.app import DATABASE_USERNAME, DATABASE_PASSWORD, DATABASE_HOST, DATABASE_PORT, DATABASE_SCHEMA_NAME
from data import relations

log = logging.getLogger(__name__)


#Section: Fixtures for Connecting to the Database
@pytest.fixture(scope="session")
def engine():
    """Creates a SQLAlchemy engine for testing.
    
    The engine object is the starting point for an SQLAlchemy application. Engines are a crucial intermediary object in how SQLAlchemy connects the user and the database. This fixture is used in `tests.test_app`, `tests.test_bp_ingest_usage`, `tests.test_bp_initialization`, `tests.test_FiscalYears`, `tests.test_StatisticsSources`, and later in this module.
    """
    engine = create_engine(
        f'mysql://{DATABASE_USERNAME}:{DATABASE_PASSWORD}@{DATABASE_HOST}:{DATABASE_PORT}/{DATABASE_SCHEMA_NAME}',
        echo=False,  # Logging configuration includes SQLAlchemy engine, so `True` causes repetition
    )
    log.info(f"`tests.conftest.engine()` yields {engine} (type {type(engine)}).")
    yield engine


@pytest.fixture(scope='session')
def app():
    """Creates an instance of the Flask object for the test session.
    
    This instance of the Flask object includes the application context (https://flask.palletsprojects.com/en/2.0.x/appcontext/) and thus access to application-level data, such as configurations, logging, and the database connection. This fixture is used in `tests.test_app` and later in this module.
    """
    app = create_app()
    app.debug = True
    app.testing = True  # Lets exceptions come through to test client
    app.env = 'test'
    app.config['SQLALCHEMY_DATABASE_URI'] = f'mysql://{DATABASE_USERNAME}:{DATABASE_PASSWORD}@{DATABASE_HOST}:{DATABASE_PORT}/{DATABASE_SCHEMA_NAME}'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  # Explicitly set to disable warning in tests
    app.config['SQLALCHEMY_ECHO'] = False  # This prevents SQLAlchemy from duplicating the log output generated by `nolcat.app.configure_logging()`
    app.config['WTF_CSRF_ENABLED'] = False  # Without this, tests involving forms return a HTTP 400 error with the message `The CSRF token is missing.`
    context = app.app_context()
    context.push()  # Binds the application context to the current context/Flask application
    log.info(f"`tests.conftest.app()` yields {app} (type {type(app)}), which is bound to {context}.")
    yield app
    context.pop()  # Removes and deletes the application context; placement after the yield statement means the action occurs at the end of the session
    log.info("`tests.conftest.app()` teardown complete.")


@pytest.fixture(scope='session')
def client(app):
    """Creates an instance of the Flask test client.
    
    The Flask test client lets tests make HTTP requests without running the server. This fixture is used in `tests.test_app`, `tests.test_FiscalYears`, and all the blueprint test modules.
    """
    client = app.test_client()
    log.info(f"`tests.conftest.client()` yields {client} (type {type(client)})")
    yield client


@pytest.fixture(scope="session")
def db(app):
    """Creates a temporary copy of the database for testing.
    
    The variable of the first statement, `_db.app`, is the Flask-SQLAlchemy integration's attribute for the Flask application (context). As a result, the fixture's first statement connects the Flask-SQLAlchemy integration to the Flask application (context) being used for testing. #ALERT: This fixture is used later in this module, but not in any tests.
    """
    #ToDo: Recreate with the sources below
    # https://github.com/alysivji/flask-family-tree-api/blob/master/tests/conftest.py as initial template
    # https://testdriven.io/blog/flask-pytest/
    # http://alexmic.net/flask-sqlalchemy-pytest/ with modifications at https://stackoverflow.com/q/28526781
    # https://spotofdata.com/flask-testing/
    # https://www.appsloveworld.com/coding/flask/3/rollback-many-transactions-between-tests-in-flask
    pass


@pytest.fixture(scope='module')
def session(engine, db):
    """Creates a database session for each test module, enabling CRUD transactions, then rolling all of them back once the module's tests are complete.
    
    First, the scope of the fixture is set to `module` because a scope of `function` would prohibit tests involving primary and foreign key relationships from using data loaded into the database during previous transactions, a more accurate reflection of actual database use. On the other hand, setting the scope to `session` would disallow the reuse of the test data, as loading test data sets multiple times would cause primary key duplication. Second, this fixture instantiates both database connection objects provided by SQLAlchemy. The connection object, used in SQLAlchemy Core and the SQL language, and the session object, used by the SQLAlchemy ORM, are both offered so the fixture can work with tests using the core or the ORM paradigm. The two objects are connected--session objects use connection objects as part of the database connection, and the fixture's session object explicitly uses its connection object. #ALERT: This fixture isn't used anywhere.
    """
    #ToDo: Recreate with the sources below
    # https://github.com/alysivji/flask-family-tree-api/blob/master/tests/conftest.py as initial template
    # https://testdriven.io/blog/flask-pytest/
    # http://alexmic.net/flask-sqlalchemy-pytest/ with modifications at https://stackoverflow.com/q/28526781
    # https://spotofdata.com/flask-testing/
    # https://www.appsloveworld.com/coding/flask/3/rollback-many-transactions-between-tests-in-flask
    pass


#Section: Test Data for Relations
@pytest.fixture
def fiscalYears_relation():
    """Creates a dataframe that can be loaded into the `fiscalYears` relation."""
    yield relations.fiscalYears_relation()


@pytest.fixture
def vendors_relation():
    """Creates a dataframe that can be loaded into the `vendors` relation."""
    yield relations.vendors_relation()


@pytest.fixture
def vendorNotes_relation():
    """Creates a dataframe that can be loaded into the `vendorNotes` relation."""
    yield relations.vendorNotes_relation()


@pytest.fixture
def statisticsSources_relation():
    """Creates a dataframe that can be loaded into the `statisticsSources` relation."""
    yield relations.statisticsSources_relation()


@pytest.fixture
def statisticsSourceNotes_relation():
    """Creates a dataframe that can be loaded into the `statisticsSourceNotes` relation."""
    yield relations.statisticsSourceNotes_relation()


@pytest.fixture
def resourceSources_relation():
    """Creates a dataframe that can be loaded into the `resourceSources` relation."""
    yield relations.resourceSources_relation()


@pytest.fixture
def resourceSourceNotes_relation():
    """Creates a dataframe that can be loaded into the `resourceSourceNotes` relation."""
    yield relations.resourceSourceNotes_relation()


@pytest.fixture
def statisticsResourceSources_relation():
    """Creates a series that can be loaded into the `statisticsResourceSources` relation."""
    yield relations.statisticsResourceSources_relation()


@pytest.fixture
def annualUsageCollectionTracking_relation():
    """Creates a dataframe that can be loaded into the `annualUsageCollectionTracking` relation."""
    yield relations.annualUsageCollectionTracking_relation()


@pytest.fixture
def COUNTERData_relation():
    """Creates a dataframe that can be loaded into the `COUNTERData` relation."""
    yield relations.COUNTERData_relation()


#Section: Other Fixtures Used in Multiple Test Modules
@pytest.fixture
def header_value():
    """A dictionary containing a HTTP request header that makes the URL request appear to come from a Chrome browser and not the requests module; some platforms return 403 errors with the standard requests header."""
    return {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.76 Safari/537.36'}


@pytest.fixture(scope='session')
def most_recent_month_with_usage():
    """Creates `begin_date` and `end_date` SUSHI parameter values representing the most recent month with available data.

    Many methods and functions call the `SUSHICallAndResponse.make_SUSHI_call()` method, so proper testing requires making a SUSHI call; for the PR, DR, TR, and IR, the call requires dates. As the most recent month with usage is unlikely to raise any errors, cause a problem with the check for previously loaded data, or return an overly large amount of data, its first and last day are used in the SUSHI API call. The two dates are returned together in a tuple and separated in the test function with index operators.

    Yields:
        tuple: two datetime.date values, representing the first and last day of a month respectively
    """
    current_date = datetime.date.today()
    if current_date.day < 10:
        begin_month = current_date + relativedelta(months=-2)
        begin_date = begin_month.replace(day=1)
    else:
        begin_month = current_date + relativedelta(months=-1)
        begin_date = begin_month.replace(day=1)
    
    end_date = datetime.date(
        begin_date.year,
        begin_date.month,
        calendar.monthrange(begin_date.year, begin_date.month)[1],
    )
    yield (begin_date, end_date)


    @pytest.fixture
    def sample_COUNTER_reports_for_MultipartEncoder():
        """Creates a `MultipartEncoder.fields` dictionary value for a `MultipleFileField`.
        
        When using the requests `post()` method on a page with a WTForms form containing `FileField` field(s), the `post()` method's `data` argument uses a `MultipartEncoder` object to contain the uploaded files. The `MultipartEncoder.fields` attribute is a dictionary where each key is the name of a `FileField` field in the form and the corresponding value is a tuple consisting of the file name and a file object (created with the `open()` function). Some WTForms fields requiring file uploads, however, are `MultipleFileFields` that take in all of the Excel workbooks in `\\nolcat\\tests\\bin\\COUNTER_workbooks_for_tests`; this fixture generates a `MultipartEncoder.fields` dictionary value tuple for all of those Excel workbooks and combines them in a tuple.
        """
        folder_path = Path('tests', 'bin', 'COUNTER_workbooks_for_tests')
        file_names = []
        for workbook in os.listdir(folder_path):
            file_names.append(workbook)
        pass  #TEST: This fixture isn't importing into other test modules; the `MultipartEncoder.fields` dictionary can only handle a single file per form field