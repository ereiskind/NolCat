"""This module contains the fixtures and configurations for testing.

The fixtures for connecting to the database are primarily based upon the fixtures at https://github.com/alysivji/flask-family-tree-api/blob/master/tests/conftest.py with some further modifications based on the code at https://spotofdata.com/flask-testing/. The test data is a small subset of the institution's own data, with usage numbers changes for confidentiality, with items selected to contain as many edge cases as possible. All test data is stored in dataframes in other files to remove encoding issues that might arise when reading data in from a tabular file but still allow the data to be exported to a tabular file.
"""

import pytest
import logging
from pathlib import Path
from datetime import date
import calendar
from random import choice
from sqlalchemy import create_engine
from requests_toolbelt.multipart.encoder import MultipartEncoder
from dateutil.relativedelta import relativedelta  # dateutil is a pandas dependency, so it doesn't need to be in requirements.txt
import botocore.exceptions  # `botocore` is a dependency of `boto3`

from nolcat.app import db as _db  # `nolcat.app` imports don't use wildcard because of need for alias here
from nolcat.app import create_app
from nolcat.app import configure_logging
from nolcat.app import s3_client
from nolcat.app import DATABASE_USERNAME, DATABASE_PASSWORD, DATABASE_HOST, DATABASE_PORT, DATABASE_SCHEMA_NAME, BUCKET_NAME, PATH_WITHIN_BUCKET
from data import relations

log = logging.getLogger(__name__)


#Section: Fixtures for Connecting to the Database
@pytest.fixture(scope="session")
def engine():
    """Creates a SQLAlchemy engine for testing.
    
    The engine object is the starting point for an SQLAlchemy application. Engines are a crucial intermediary object in how SQLAlchemy connects the user and the database. This fixture is used in `tests.test_app`, `tests.test_bp_ingest_usage`, `tests.test_bp_initialization`, `tests.test_FiscalYears`, `tests.test_StatisticsSources`, and later in this module.

    Yields:
        sqlalchemy.engine.Engine: a SQLAlchemy engine
    """
    engine = create_engine(
        f'mysql://{DATABASE_USERNAME}:{DATABASE_PASSWORD}@{DATABASE_HOST}:{DATABASE_PORT}/{DATABASE_SCHEMA_NAME}',
        echo=False,  # Logging configuration includes SQLAlchemy engine, so `True` causes repetition
    )
    log.info(f"`tests.conftest.engine()` yields {engine} (type {type(engine)}).")
    yield engine


@pytest.fixture(scope='session')
def app():
    """Creates an instance of the Flask object for the test session.
    
    This instance of the Flask object includes the application context (https://flask.palletsprojects.com/en/2.0.x/appcontext/) and thus access to application-level data, such as configurations, logging, and the database connection. This fixture is used in `tests.test_app` and later in this module.

    Yields:
        flask.Flask: a Flask object
    """
    app = create_app()
    app.debug = True
    app.testing = True  # Lets exceptions come through to test client
    app.env = 'test'
    app.config['SQLALCHEMY_DATABASE_URI'] = f'mysql://{DATABASE_USERNAME}:{DATABASE_PASSWORD}@{DATABASE_HOST}:{DATABASE_PORT}/{DATABASE_SCHEMA_NAME}'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  # Explicitly set to disable warning in tests
    app.config['SQLALCHEMY_ECHO'] = False  # This prevents SQLAlchemy from duplicating the log output generated by `nolcat.app.configure_logging()`
    app.config['WTF_CSRF_ENABLED'] = False  # Without this, tests involving forms return a HTTP 400 error with the message `The CSRF token is missing.`
    configure_logging(app)
    context = app.app_context()
    context.push()  # Binds the application context to the current context/Flask application
    log.info(f"`tests.conftest.app()` yields {app} (type {type(app)}), which is bound to {context}.")
    yield app
    context.pop()  # Removes and deletes the application context; placement after the yield statement means the action occurs at the end of the session
    log.info("`tests.conftest.app()` teardown complete.")


@pytest.fixture(scope='session')
def client(app):
    """Creates an instance of the Flask test client.
    
    The Flask test client lets tests make HTTP requests without running the server. This fixture is used in `tests.test_app`, `tests.test_FiscalYears`, and all the blueprint test modules.

    Args:
        app (flask.Flask): a Flask object

    Yields:
        flask.testing.FlaskClient: a way to test HTTP calls without running a live server
    """
    client = app.test_client()
    log.info(f"`tests.conftest.client()` yields {client} (type {type(client)}).")
    yield client


@pytest.fixture(scope="session")
def db(app):
    """Creates a temporary copy of the database for testing.
    
    The variable of the first statement, `_db.app`, is the Flask-SQLAlchemy integration's attribute for the Flask application (context). As a result, the fixture's first statement connects the Flask-SQLAlchemy integration to the Flask application (context) being used for testing. #ALERT: This fixture is used later in this module, but not in any tests.
    """
    #ToDo: Recreate with the sources below
    # https://github.com/alysivji/flask-family-tree-api/blob/master/tests/conftest.py as initial template
    # https://testdriven.io/blog/flask-pytest/
    # http://alexmic.net/flask-sqlalchemy-pytest/ with modifications at https://stackoverflow.com/q/28526781
    # https://spotofdata.com/flask-testing/
    # https://www.appsloveworld.com/coding/flask/3/rollback-many-transactions-between-tests-in-flask
    pass


@pytest.fixture(scope='module')
def session(engine, db):
    """Creates a database session for each test module, enabling CRUD transactions, then rolling all of them back once the module's tests are complete.
    
    First, the scope of the fixture is set to `module` because a scope of `function` would prohibit tests involving primary and foreign key relationships from using data loaded into the database during previous transactions, a more accurate reflection of actual database use. On the other hand, setting the scope to `session` would disallow the reuse of the test data, as loading test data sets multiple times would cause primary key duplication. Second, this fixture instantiates both database connection objects provided by SQLAlchemy. The connection object, used in SQLAlchemy Core and the SQL language, and the session object, used by the SQLAlchemy ORM, are both offered so the fixture can work with tests using the core or the ORM paradigm. The two objects are connected--session objects use connection objects as part of the database connection, and the fixture's session object explicitly uses its connection object. #ALERT: This fixture isn't used anywhere.
    """
    #ToDo: Recreate with the sources below
    # https://github.com/alysivji/flask-family-tree-api/blob/master/tests/conftest.py as initial template
    # https://testdriven.io/blog/flask-pytest/
    # http://alexmic.net/flask-sqlalchemy-pytest/ with modifications at https://stackoverflow.com/q/28526781
    # https://spotofdata.com/flask-testing/
    # https://www.appsloveworld.com/coding/flask/3/rollback-many-transactions-between-tests-in-flask
    pass


#Section: Test Data for Relations
@pytest.fixture
def fiscalYears_relation():
    """Creates a dataframe that can be loaded into the `fiscalYears` relation.
    
    Yields:
        dataframe: a relation of test data
    """
    yield relations.fiscalYears_relation()


@pytest.fixture
def vendors_relation():
    """Creates a dataframe that can be loaded into the `vendors` relation.
    
    Yields:
        dataframe: a relation of test data
    """
    yield relations.vendors_relation()


@pytest.fixture
def vendorNotes_relation():
    """Creates a dataframe that can be loaded into the `vendorNotes` relation.
    
    Yields:
        dataframe: a relation of test data
    """
    yield relations.vendorNotes_relation()


@pytest.fixture
def statisticsSources_relation():
    """Creates a dataframe that can be loaded into the `statisticsSources` relation.
    
    Yields:
        dataframe: a relation of test data
    """
    yield relations.statisticsSources_relation()


@pytest.fixture
def statisticsSourceNotes_relation():
    """Creates a dataframe that can be loaded into the `statisticsSourceNotes` relation.
    
    Yields:
        dataframe: a relation of test data
    """
    yield relations.statisticsSourceNotes_relation()


@pytest.fixture
def resourceSources_relation():
    """Creates a dataframe that can be loaded into the `resourceSources` relation.
    
    Yields:
        dataframe: a relation of test data
    """
    yield relations.resourceSources_relation()


@pytest.fixture
def resourceSourceNotes_relation():
    """Creates a dataframe that can be loaded into the `resourceSourceNotes` relation.
    
    Yields:
        dataframe: a relation of test data
    """
    yield relations.resourceSourceNotes_relation()


@pytest.fixture
def statisticsResourceSources_relation():
    """Creates a series that can be loaded into the `statisticsResourceSources` relation.
    
    Yields:
        dataframe: a relation of test data
    """
    yield relations.statisticsResourceSources_relation()


@pytest.fixture
def annualUsageCollectionTracking_relation():
    """Creates a dataframe that can be loaded into the `annualUsageCollectionTracking` relation.
    
    Yields:
        dataframe: a relation of test data
    """
    yield relations.annualUsageCollectionTracking_relation()


@pytest.fixture
def COUNTERData_relation():
    """Creates a dataframe that can be loaded into the `COUNTERData` relation.
    
    Yields:
        dataframe: a relation of test data
    """
    yield relations.COUNTERData_relation()


#Section: Other Fixtures Used in Multiple Test Modules
@pytest.fixture
def header_value():
    """A dictionary containing a HTTP request header that makes the URL request appear to come from a Chrome browser and not the requests module; some platforms return 403 errors with the standard requests header.
    
    Yields:
        dict: HTTP header data
    """
    return {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.76 Safari/537.36'}


@pytest.fixture(scope='session')
def most_recent_month_with_usage():
    """Creates `begin_date` and `end_date` SUSHI parameter values representing the most recent month with available data.

    Many methods and functions call the `SUSHICallAndResponse.make_SUSHI_call()` method, so proper testing requires making a SUSHI call; for the PR, DR, TR, and IR, the call requires dates. As the most recent month with usage is unlikely to raise any errors, cause a problem with the check for previously loaded data, or return an overly large amount of data, its first and last day are used in the SUSHI API call. The two dates are returned together in a tuple and separated in the test function with index operators.

    Yields:
        tuple: two datetime.date values, representing the first and last day of a month respectively
    """
    current_date = date.today()
    if current_date.day < 15:
        begin_month = current_date + relativedelta(months=-2)
        begin_date = begin_month.replace(day=1)
    else:
        begin_month = current_date + relativedelta(months=-1)
        begin_date = begin_month.replace(day=1)
    
    end_date = date(
        begin_date.year,
        begin_date.month,
        calendar.monthrange(begin_date.year, begin_date.month)[1],
    )
    yield (begin_date, end_date)


@pytest.fixture(scope='module')
def default_download_folder():
    """Provides the path to the host workstation's downloads folder.
    
    Yields:
        pathlib.Path: a path to the host workstation's downloads folder
    """
    #ToDo: If method for interacting with host workstation's file system can be established, `yield input("Enter the absolute path to the computer's downloads folder: ")`
    '''If `os.name` can be replaced by another attribute or method for finding the host computer's OS
        if os.name == 'nt':  # Windows
            return Path(os.getenv('USERPROFILE')) / 'Downloads'
        else:  # *Nix systems, including macOS
            return Path(os.getenv('HOME')) / 'Downloads'
    '''
    pass


@pytest.fixture(params=[Path(__file__).parent / 'data' / 'COUNTER_JSONs_for_tests', Path(__file__).parent / 'bin' / 'sample_COUNTER_R4_reports'])
def files_for_testing(request):
    """Handles the selection and removal of files for testing uploads and downloads.
    
    This fixture uses parameterization to randomly select two files--one text and one binary--to test both uploading to an S3 bucket and downloading from a location in the NoLCAT repo, then removes the files created by those tests. The `sample_COUNTER_R4_reports` folder is used for binary data because all of the files within are under 30KB; there is no similar way to limit the file size for text data, as the files in `COUNTER_JSONs_for_tests` can be over 6,000KB.

    Args:
        request (pathlib.Path): an absolute path to a folder with test data

    Yields:
        pathlib.Path: an absolute file path to a randomly selected file
    """
    file_path = request.param
    file_name = choice([file.name for file in file_path.iterdir()])
    file_path_and_name = file_path / file_name
    yield file_path_and_name

    #ToDo: If method for interacting with host workstation's file system can be established, add `default_download_folder` to parameters, then `Path(default_download_folder).unlink(missing_ok=True)`
    try:
        s3_client.delete_object(
            Bucket=BUCKET_NAME,
            Key=f"{PATH_WITHIN_BUCKET}test_{file_name}"
        )
    except botocore.exceptions as error:
        log.error(f"Trying to remove the test data files from the S3 bucket raised {error}.")


@pytest.fixture
def sample_COUNTER_reports_for_MultipartEncoder():
    """Creates a `MultipartEncoder.fields` dictionary value for a `MultipleFileField`.
    
    When using the requests `post()` method on a page with a WTForms form containing `FileField` field(s), the `post()` method's `data` argument uses a `MultipartEncoder` object to contain the uploaded files. The `MultipartEncoder.fields` attribute is a dictionary where each key is the name of a `FileField` field in the form and the corresponding value is a tuple consisting of the file name and a file object (created with the `open()` function). Some WTForms fields requiring file uploads, however, are `MultipleFileFields` that take in all of the Excel workbooks in `\\nolcat\\tests\\bin\\COUNTER_workbooks_for_tests`; this fixture generates a `MultipartEncoder.fields` dictionary value tuple for all of those Excel workbooks and combines them in a tuple.

    Yields:
        MultipartEncoder.fields: a representation of multiple files selected in a MultipleFileField
    """
    folder_path = Path(__file__) / 'bin' / 'COUNTER_workbooks_for_tests'
    file_names = []
    for workbook in folder_path.iterdir():
        file_names.append(workbook)
    pass  #TEST: This fixture isn't importing into other test modules; the `MultipartEncoder.fields` dictionary can only handle a single file per form field


#Section: Replacement Classes
class _fileAttribute:
    """Enables the `_file` attribute of the `mock_FileStorage_object.stream` attribute.

    Attributes:
        self._file (str): The absolute file path for the COUNTER report being uploaded
    """
    def __init__(self, file_path):
        """The constructor method for `_fileAttribute`, which instantiates the string of the absolute file path for the COUNTER report being uploaded."""
        self._file = str(file_path)


class mock_FileStorage_object:
    """A replacement for a Werkzeug FileStorage object.

    Some class constructors, functions, and methods use an individual or a list of Werkzeug FileStorage objects--the `data` attribute of a WTForms FileField or MultipleFileField object respectively--as an argument. When a list of Werkzeug FileStorage object(s) created with the FileStorage constructor in a fixture is used, however, the _io.BytesIO object returned by the `.stream._file` attribute often raises a `File is not a zip file` error in OpenPyXL's `load_workbook()` function. With the same files encapsulated in the same classes raising an error depending on their source, it could not be determined how to prevent the FileStorage object(s) created in the fixture from raising the error. As an alternative, this class was created; it has the attributes of the Werkzeug FileStorage object needed for the tests its used in, so it works the same way in the method, but it features the absolute file path as a string instead of a _io.BytesIO object to avoid the `File is not a zip file` error.

    Attributes:
        self.stream (_fileAttribute._file): The intermediary attribute for the absolute file path for the COUNTER report being uploaded
        self.filename (str): The name of the file of the COUNTER report being uploaded
    """
    def __init__(self, file_path):
        """The constructor method for `mock_FileStorage_object`, which instantiates the attributes `stream` and `filename` based on the absolute file path for the COUNTER report being uploaded.

        Args:
            file_path (pathlib.Path): The absolute file path for the COUNTER report being uploaded
        """
        self.stream = _fileAttribute(file_path.absolute())
        self.filename = file_path.name


    def __repr__(self):
        """The printable representation of a `mock_FileStorage_object` instance."""
        return f"<__main__.mock_FileStorage_object {{'stream._file': '{self.stream._file}', 'filename': '{self.filename}'}}>"